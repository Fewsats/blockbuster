// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: invoice_status.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const getInvoiceStatus = `-- name: GetInvoiceStatus :one
SELECT payment_hash, settled, preimage, created_at, updated_at FROM invoice_status WHERE payment_hash = ?
`

func (q *Queries) GetInvoiceStatus(ctx context.Context, paymentHash string) (InvoiceStatus, error) {
	row := q.db.QueryRowContext(ctx, getInvoiceStatus, paymentHash)
	var i InvoiceStatus
	err := row.Scan(
		&i.PaymentHash,
		&i.Settled,
		&i.Preimage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertInvoiceStatus = `-- name: UpsertInvoiceStatus :one
INSERT INTO invoice_status (payment_hash, settled, preimage, created_at, updated_at)
VALUES (?, ?, ?, ?, ?)
ON CONFLICT (payment_hash) DO UPDATE SET
    settled = EXCLUDED.settled,
    preimage = EXCLUDED.preimage,
    updated_at = EXCLUDED.updated_at
RETURNING payment_hash, settled, preimage, created_at, updated_at
`

type UpsertInvoiceStatusParams struct {
	PaymentHash string
	Settled     bool
	Preimage    sql.NullString
	CreatedAt   time.Time
	UpdatedAt   time.Time
}

func (q *Queries) UpsertInvoiceStatus(ctx context.Context, arg UpsertInvoiceStatusParams) (InvoiceStatus, error) {
	row := q.db.QueryRowContext(ctx, upsertInvoiceStatus,
		arg.PaymentHash,
		arg.Settled,
		arg.Preimage,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i InvoiceStatus
	err := row.Scan(
		&i.PaymentHash,
		&i.Settled,
		&i.Preimage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
